# admin tables including 'admin', 'test', 'time', 'timeline', 'status'
# and 'version' are created systematically

# sys tables to be processed in the main loop. They all have to start
# with the prefix 'sys_'

# number of processes indexed by the wall-clock time
sys_procs {
      id text :index None;
      wctime real :wctime;
      numprocs integer :numprocs Error;
}

# number of threads indexed by the wall-clock time
sys_threads {
      id text :index;
      wctime real :wctime;
      numthreads integer :numthreads Error;
}

# cpu time indexed by wall-clock time
sys_time {
      id text :index Error;
      wctime real :wctime Error;
      cputime real :cputime Error;
}

# memory usage indexed by the wall-clock time
sys_vsize {
      id text :index Error;
      wctime real :wctime Error;
      vsize real :vsize Error;
}

# data tables to be processed after the completion of the
# executable. They all have to start with the prefix 'data_'

# heuristic value of the start state
data_h {
      id text :index;
      value integer ?h;
}

# optimal cost of every problem
data_optimal_cost {
      id text :index;
      cost integer ?'Solution length' Error;
}

# number of expansions of eIDA*
data_expansions_eida {
      id text :index;
      value integer ?"expansions eIDA" Warning;
}

# number of expansions of IDA*
data_expansions_ida {
      id text :index;
      value integer ?'expansions IDA' Warning;
}

# scatterplot of the number of expansions by both algorithms
data_expansions {
	id text :index;
	eIDA integer ?'expansions eIDA' Warning;
	IDA integer ?'expansions IDA' Warning;
}

# number of iterations of IDA*
data_iterations_ida {
	id text :index;
	iterations integer ?'iterations IDA' Error;
}

# number of iterations of eIDA*
data_iterations_eida {
	id text :index;
	iterations integer ?'iterations eIDA' Error;
}

# scatterplot of the number of iterations of both IDA* and eIDA*
data_iterations {
	id text :index;
	init text @init;
	eIDA integer ?'iterations eIDA' Error;
	IDA integer ?'iterations IDA' Error;
}
